using System;
using System.Numerics;

public static class WorkObjectXform
{
    // Corners must be ordered TL, TR, BR, BL (single scan).
    // Returns a 3x3 rotation matrix where columns are the work axes expressed in world coordinates:
    //   col0 = Xwork_in_world, col1 = Ywork_in_world, col2 = Zwork_in_world (normal).
    public static Matrix4x4 RotationMatrixFromFiducial4Corners(ReadOnlySpan<Vector3> cornersTLTRBRBL)
    {
        if (cornersTLTRBRBL.Length != 4) throw new ArgumentException("Expected 4 corners: TL,TR,BR,BL.");

        var c = cornersTLTRBRBL;

        var top    = c[1] - c[0]; // TR - TL
        var bottom = c[2] - c[3]; // BR - BL
        var left   = c[3] - c[0]; // BL - TL
        var right  = c[2] - c[1]; // BR - TR

        var x = Vector3.Normalize(top + bottom);
        var y0 = Vector3.Normalize(left + right);

        var z = Vector3.Normalize(Vector3.Cross(x, y0));
        var y = Vector3.Normalize(Vector3.Cross(z, x));

        return new Matrix4x4(
            x.X, y.X, z.X, 0f,
            x.Y, y.Y, z.Y, 0f,
            x.Z, y.Z, z.Z, 0f,
            0f,  0f,  0f,  1f
        );
    }

    // Converts a work-coordinate point into world coordinates.
    // - cornersTLTRBRBL: fiducial corners (TL,TR,BR,BL) in world coordinates
    // - workPt: (u,v,w) in work coordinates (typically w=0 for points on the fiducial plane)
    // - linearOffset: extra offset along work axes (du,dv,dw) applied before transforming (e.g., tool offset)
    public static Vector3 WorkPointToWorld(
        ReadOnlySpan<Vector3> cornersTLTRBRBL,
        in Vector3 workPt,
        in Vector3 linearOffset)
    {
        if (cornersTLTRBRBL.Length != 4) throw new ArgumentException("Expected 4 corners: TL,TR,BR,BL.");

        var origin = (cornersTLTRBRBL[0] + cornersTLTRBRBL[1] + cornersTLTRBRBL[2] + cornersTLTRBRBL[3]) * 0.25f;
        var R = RotationMatrixFromFiducial4Corners(cornersTLTRBRBL);

        var p = workPt + linearOffset;

        // world = origin + R * p  (R stored with axes in columns)
        return new Vector3(
            origin.X + R.M11 * p.X + R.M12 * p.Y + R.M13 * p.Z,
            origin.Y + R.M21 * p.X + R.M22 * p.Y + R.M23 * p.Z,
            origin.Z + R.M31 * p.X + R.M32 * p.Y + R.M33 * p.Z
        );
    }
}