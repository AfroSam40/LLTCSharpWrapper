/// <summary>
/// Set the scanner to free-run (internal trigger) at approximately the given frequency (Hz).
/// Keeps the current exposure time and adjusts idle time so that
/// (exposure + idle) ≈ 1/frequency.
/// </summary>
public bool SetScanFrequencyHz(double frequencyHz)
{
    if (!_connected)
        throw new InvalidOperationException("Sensor not connected. Call Connect() first.");

    if (frequencyHz <= 0)
        throw new ArgumentOutOfRangeException(nameof(frequencyHz), "frequencyHz must be > 0.");

    // Total period in microseconds for the requested frequency
    // T = 1/f ⇒ T_us = 1e6 / f
    double periodUs = 1_000_000.0 / frequencyHz;

    // Keep current exposure time, adjust idle so exposure + idle = period
    double idleUs = periodUs - _exposureTime;

    // If the requested frequency is too high for the current exposure time,
    // clamp idle time to 0 and you effectively get the max possible frequency
    if (idleUs < 0)
        idleUs = 0;

    uint idle = (uint)Math.Round(idleUs);
    uint exposure = _exposureTime; // already in µs

    // Make sure we're in internal trigger mode
    int ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_TRIGGER, CLLTI.TRIG_INTERNAL);
    if (ret < CLLTI.GENERAL_FUNCTION_OK)
    {
        SetError("SetScanFrequencyHz / SetFeature(TRIGGER)", ret);
        return false;
    }

    // Set exposure time (µs)
    ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_EXPOSURE_TIME, exposure);
    if (ret < CLLTI.GENERAL_FUNCTION_OK)
    {
        SetError("SetScanFrequencyHz / SetFeature(EXPOSURE_TIME)", ret);
        return false;
    }

    // Set idle time (µs)
    ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_IDLE_TIME, idle);
    if (ret < CLLTI.GENERAL_FUNCTION_OK)
    {
        SetError("SetScanFrequencyHz / SetFeature(IDLE_TIME)", ret);
        return false;
    }

    _idleTime = idle;
    return true;
}

/// <summary>
/// Set the scanner to run at the specified frequency (Hz),
/// then collect a given number of profiles using the callback-based AsyncPoll.
/// Timeout is computed automatically from profileCount and frequencyHz
/// with a configurable safety factor.
/// </summary>
public async Task<List<Profile>> CaptureProfilesAtFrequencyAsync(
    int profileCount,
    double frequencyHz,
    double safetyFactor = 2.0)
{
    if (!_connected)
        throw new InvalidOperationException("Sensor not connected. Call Connect() first.");

    if (profileCount <= 0)
        throw new ArgumentOutOfRangeException(nameof(profileCount), "profileCount must be > 0.");

    if (frequencyHz <= 0)
        throw new ArgumentOutOfRangeException(nameof(frequencyHz), "frequencyHz must be > 0.");

    if (safetyFactor <= 0)
        safetyFactor = 1.0;

    // 1) Configure the LLT to free-run at the requested frequency
    if (!SetScanFrequencyHz(frequencyHz))
        throw new Exception(ErrorMessage ?? "Failed to set scan frequency.");

    // Give the device a tiny moment to settle
    await Task.Delay(50);

    // 2) Compute a reasonable timeout:
    //    Ideal time (s) = profileCount / frequencyHz
    //    => in ms: 1000 * profileCount / frequencyHz
    double idealTotalMs = 1000.0 * profileCount / frequencyHz;
    double timeoutMsDouble = idealTotalMs * safetyFactor;

    // Enforce some bounds
    if (timeoutMsDouble < 100)
        timeoutMsDouble = 100; // at least 100 ms
    if (timeoutMsDouble > int.MaxValue)
        timeoutMsDouble = int.MaxValue;

    int timeoutMs = (int)Math.Ceiling(timeoutMsDouble);

    // 3) Use the existing callback-based async polling
    return await AsyncPoll(profileCount, timeoutMs);
}