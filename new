public async Task<List<Profile>> CaptureEncoderBatchAsync(
    int profileCount,
    uint exposureTimeUs,
    int timeoutMs = 2000)
{
    if (!_connected)
        throw new InvalidOperationException("Sensor not connected. Call Connect() first.");

    if (profileCount <= 0)
        throw new ArgumentOutOfRangeException(nameof(profileCount), "profileCount must be > 0.");

    // Prevent running two async acquisitions at once on this device
    if (Interlocked.Exchange(ref _asyncInUse, 1) == 1)
        throw new InvalidOperationException("An async acquisition is already running on this sensor.");

    uint resolution = (uint)_resolution;

    try
    {
        // --- Configure sensor for encoder-triggered acquisition ---

        // 1) Exposure time (Âµs)
        _exposureTime = exposureTimeUs;
        int ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_EXPOSURE_TIME, _exposureTime);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(EXPOSURE_TIME)", ret);
            throw new Exception(ErrorMessage);
        }

        // 2) Trigger: encoder-based, RS422 input, rising edge, external active
        //    (you may need to adjust TRIG_INPUT_* depending on your wiring)
        uint trigConfig =
            CLLTI.TRIG_MODE_ENCODER |   // use encoder mode
            CLLTI.TRIG_INPUT_RS422 |    // encoder on RS422 (IN2/IN3 via RS422 port)
            CLLTI.TRIG_POLARITY_HIGH |  // rising edge
            CLLTI.TRIG_EXT_ACTIVE;      // external trigger active

        ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_TRIGGER, trigConfig);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(TRIGGER_ENCODER)", ret);
            throw new Exception(ErrorMessage);
        }

        // NOTE: If you want "gated encoder" behaviour via multipurpose input,
        // you'd additionally configure FEATURE_FUNCTION_DIGITAL_IO with
        // MULTI_DIGIN_GATED_ENCODER and appropriate level/RS422 flags.

        // --- Prepare async state for callback-based acquisition ---

        int singleProfileBytes = checked((int)(resolution * 64));  // same as Poll/AsyncPoll
        _asyncProfileBuffer = new byte[singleProfileBytes * profileCount];
        _asyncProfileDataSize = 0;
        _asyncNeededProfiles = profileCount;
        _asyncReceivedProfiles = 0;
        _profileEvent.Reset();

        // Let parameters settle a bit
        await Task.Delay(120).ConfigureAwait(false);

        // --- Start continuous transmission in NORMAL_CONTAINER_MODE ---

        ret = CLLTI.TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 1);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("TransferProfiles(start, NORMAL_CONTAINER_MODE)", ret);
            throw new Exception(ErrorMessage);
        }

        try
        {
            // Wait for the callback to collect the requested number of profiles
            bool signaled = await Task.Run(() => _profileEvent.WaitOne(timeoutMs))
                                      .ConfigureAwait(false);

            if (!signaled || _asyncReceivedProfiles < _asyncNeededProfiles)
            {
                SetError("CaptureEncoderBatchAsync timeout", CLLTI.ERROR_PROFTRANS_NO_NEW_PROFILE);
                throw new TimeoutException(
                    $"Timed out waiting for {_asyncNeededProfiles} profiles. Received: {_asyncReceivedProfiles}");
            }

            // Sanity check: profile size from callback must match expected bytes
            if (_asyncProfileDataSize != resolution * 64)
            {
                SetError("CaptureEncoderBatchAsync size mismatch", (int)_asyncProfileDataSize);
                throw new Exception(
                    $"Profile size mismatch: expected {resolution * 64}, got {_asyncProfileDataSize}");
            }

            // --- Convert each captured profile into X/Z arrays and wrap as Profile ---

            var profiles = new List<Profile>(_asyncNeededProfiles);
            var xValues = new double[resolution];
            var zValues = new double[resolution];
            var singleBuffer = new byte[singleProfileBytes];

            for (int p = 0; p < _asyncNeededProfiles; p++)
            {
                // Copy one profile out of the big async buffer
                Buffer.BlockCopy(
                    _asyncProfileBuffer,
                    p * singleProfileBytes,
                    singleBuffer,
                    0,
                    singleProfileBytes);

                ret = CLLTI.ConvertProfile2Values(
                    device,
                    singleBuffer,
                    resolution,
                    TProfileConfig.PROFILE,
                    _scannerType,
                    0,   // reflection 0
                    1,   // convert to mm
                    null, null, null,
                    xValues,
                    zValues,
                    null, null);

                if (((ret & CLLTI.CONVERT_X) == 0) || ((ret & CLLTI.CONVERT_Z) == 0))
                {
                    SetError("ConvertProfile2Values", ret);
                    throw new Exception(ErrorMessage);
                }

                var prof = new Profile(new List<ScanPoint>((int)resolution));
                for (int i = 0; i < resolution; i++)
                {
                    prof.Add(new ScanPoint
                    {
                        X = xValues[i],
                        Z = zValues[i]
                    });
                }

                profiles.Add(prof);
            }

            ErrorMessage = null;
            return profiles;
        }
        finally
        {
            // Stop transmission
            CLLTI.TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 0);

            // (Optionally) restore internal trigger so Poll() keeps working as before
            // You can comment this out if you want to stay in encoder mode:
            int retRestore = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_TRIGGER, CLLTI.TRIG_INTERNAL);
            if (retRestore < CLLTI.GENERAL_FUNCTION_OK)
            {
                SetError("Restore TRIG_INTERNAL", retRestore);
            }

            // Clear async state
            _asyncProfileBuffer = null;
            _asyncProfileDataSize = 0;
            _asyncNeededProfiles = 0;
            _asyncReceivedProfiles = 0;
        }
    }
    finally
    {
        Interlocked.Exchange(ref _asyncInUse, 0);
    }
}