private uint ComputeContainerRearrangement(uint resolution)
{
    int idx;
    switch (resolution)
    {
        case 256:  idx = 0; break;
        case 512:  idx = 1; break;
        case 1024: idx = 2; break;
        case 2048: idx = 3; break;
        default:
            // Fallback: map power-of-two resolutions to 0..7
            idx = (int)Math.Round(Math.Log(resolution / 256.0, 2.0));
            if (idx < 0) idx = 0;
            if (idx > 7) idx = 7;
            break;
    }

    // Match Python: Z + X + stripe 1 + resolution index in upper bits
    return (uint)(
        CLLTI.CONTAINER_DATA_Z |
        CLLTI.CONTAINER_DATA_X |
        CLLTI.CONTAINER_STRIPE_1 |
        (idx << 12));
}


---------

public async Task<List<Profile>> CaptureEncoderBatchContainerAsync(
    int numProfiles,
    uint exposureTimeUs,
    int timeoutMs = 0)
{
    if (!_connected)
        throw new InvalidOperationException("Sensor not connected.");

    if (numProfiles <= 0)
        throw new ArgumentOutOfRangeException(nameof(numProfiles));

    if (Interlocked.Exchange(ref _asyncInUse, 1) == 1)
        throw new InvalidOperationException("Another async operation is already running.");

    uint resolution = (uint)_resolution;

    try
    {
        int ret;

        // =========================
        // 1) Trigger / encoder setup
        // =========================

        // Enable encoder maintenance
        ret = SetFeature(device, FEATURE_FUNCTION_MAINTENANCE, MAINTENANCE_ENCODER_ACTIVE);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(MAINTENANCE_ENCODER_ACTIVE)", ret);
            throw new Exception(ErrorMessage);
        }

        // Route 24V digital input to encoder (matches Python "multi_port")
        uint multiPort = MULTI_DIGIN_ENC_INDEX | MULTI_LEVEL_SV | MULTI_INPUT_PULLUP;
        ret = SetFeature(device, FEATURE_FUNCTION_DIGITAL_IO, multiPort);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(DIGITAL_IO)", ret);
            throw new Exception(ErrorMessage);
        }

        // Trigger mode: encoder on digital input, external active
        uint trigger = TRIG_MODE_ENCODER | TRIG_INPUT_DIGIN | TRIG_EXT_ACTIVE;
        ret = SetFeature(device, FEATURE_FUNCTION_TRIGGER, trigger);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(TRIGGER ENCODER)", ret);
            throw new Exception(ErrorMessage);
        }

        // Exposure time (Python uses microseconds as well)
        ret = SetFeature(device, FEATURE_FUNCTION_EXPOSURE_TIME, exposureTimeUs);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(EXPOSURE_TIME)", ret);
            throw new Exception(ErrorMessage);
        }

        // =========================
        // 2) Rearrangement & container config
        // =========================

        uint rearrangement = ComputeContainerRearrangement(resolution);
        ret = SetFeature(device, FEATURE_FUNCTION_PROFILE_REARRANGEMENT, rearrangement);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(PROFILE_REARRANGEMENT)", ret);
            throw new Exception(ErrorMessage);
        }

        // Profile config: CONTAINER (not PROFILE)
        ret = SetProfileConfig(device, TProfileConfig.CONTAINER);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetProfileConfig(CONTAINER)", ret);
            throw new Exception(ErrorMessage);
        }

        // Container size: Python uses width=0, height=numProfiles
        // width=0 => scanner chooses appropriate width based on rearrangement
        ret = SetProfileContainerSize(device, 0, (uint)numProfiles);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("SetProfileContainerSize", ret);
            throw new Exception(ErrorMessage);
        }

        // =========================
        // 3) Allocate buffer like Python: resolution * 4 * numProfiles
        // =========================

        int containerBytes = checked((int)(resolution * 4u * (uint)numProfiles));
        _asyncProfileBuffer      = new byte[containerBytes];
        _asyncProfileDataSize    = 0;
        _asyncExpectedChunkBytes = containerBytes;
        _asyncNeededProfiles     = 1;     // exactly one container callback
        _asyncReceivedProfiles   = 0;
        _profileEvent.Reset();

        if (timeoutMs <= 0)
        {
            // Python uses event.wait(90) seconds
            timeoutMs = 90000;
        }

        // Warmup like Python's "time.sleep(0.1)"
        await Task.Delay(100);

        // =========================
        // 4) Start transfer in NORMAL_CONTAINER_MODE
        // =========================

        ret = TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 1);
        if (ret < GENERAL_FUNCTION_OK)
        {
            SetError("TransferProfiles(NORMAL_CONTAINER_MODE,1)", ret);
            throw new Exception(ErrorMessage);
        }

        try
        {
            bool gotEvent = await Task.Run(() => _profileEvent.WaitOne(timeoutMs));
            if (!gotEvent)
            {
                SetError("CaptureEncoderBatchContainerAsync timeout", ERROR_PROFTRANS_NO_NEW_PROFILE);
                throw new TimeoutException("Timeout waiting for container.");
            }

            if (_asyncProfileDataSize != (uint)containerBytes)
            {
                // This is exactly where your "size does not meet expected" used to show up.
                // With the 4-bytes-per-point size, this should now match.
                SetError("Container size mismatch", (int)_asyncProfileDataSize);
                throw new Exception($"Expected {containerBytes} bytes, got {_asyncProfileDataSize}");
            }

            // =========================
            // 5) Convert container to X/Z via ConvertContainer2Values
            // =========================

            uint resultsSize = resolution * (uint)numProfiles; // same as Python: results_size = resolution * num_profiles
            var xResults = new double[resultsSize];
            var zResults = new double[resultsSize];

            // You'll need the exact struct from your C# wrapper:
            // It should correspond to Python's TConvertContainerParameter.
            var param = new TConvertContainerParameter
            {
                // Field names may differ slightly in your wrapper â€“ adapt as needed.
                abyProfileContainer = _asyncProfileBuffer,
                uiRearrangement     = rearrangement,
                uiProfileCount      = (uint)numProfiles,
                tScannerType        = _scannerType,
                uiReflection        = 0,
                uiConvertToMM       = 1,
                padwValidMask       = null,
                padwMaxPos          = null,
                padwMaxWidth        = null,
                padfX               = xResults,
                padfZ               = zResults,
                padfM0              = null,
                padfM1              = null
            };

            ret = ConvertContainer2Values(device, ref param);
            if (ret < GENERAL_FUNCTION_OK ||
                ((ret & CONVERT_X) == 0) ||
                ((ret & CONVERT_Z) == 0))
            {
                SetError("ConvertContainer2Values", ret);
                throw new Exception(ErrorMessage);
            }

            // =========================
            // 6) Slice X/Z into Profile objects
            // =========================

            var profiles = new List<Profile>(numProfiles);

            for (int p = 0; p < numProfiles; p++)
            {
                var list = new List<ScanPoint>((int)resolution);
                int offset = p * (int)resolution;

                for (int i = 0; i < resolution; i++)
                {
                    list.Add(new ScanPoint
                    {
                        X = xResults[offset + i],
                        Z = zResults[offset + i]
                    });
                }

                profiles.Add(new Profile(list));
            }

            ErrorMessage = null;
            return profiles;
        }
        finally
        {
            TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 0);

            _asyncProfileBuffer      = null;
            _asyncProfileDataSize    = 0;
            _asyncExpectedChunkBytes = 0;
            _asyncNeededProfiles     = 0;
            _asyncReceivedProfiles   = 0;
        }
    }
    finally
    {
        Interlocked.Exchange(ref _asyncInUse, 0);
    }
}