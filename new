public async Task<List<Profile>> CaptureEncoderBatchAsync(
    int profileCount,
    uint exposureTimeUs,
    int timeoutMs = 2000)
{
    if (!_connected)
        throw new InvalidOperationException("Sensor not connected. Call Connect() first.");

    if (profileCount <= 0)
        throw new ArgumentOutOfRangeException(nameof(profileCount), "profileCount must be > 0.");

    // Prevent running two async acquisitions at once on this sensor
    if (Interlocked.Exchange(ref _asyncInUse, 1) == 1)
        throw new InvalidOperationException("An async acquisition is already running on this sensor.");

    uint resolution = (uint)_resolution;

    try
    {
        int singleProfileBytes = checked((int)(resolution * 64));
        int totalBytes = checked(singleProfileBytes * profileCount);

        // --- Configure container so ONE container holds ALL requested profiles ---

        uint maxWidth = 0, maxHeight = 0;
        int ret = CLLTI.GetMaxProfileContainerSize(device, ref maxWidth, ref maxHeight);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("GetMaxProfileContainerSize", ret);
            throw new Exception(ErrorMessage);
        }

        uint width = resolution;
        uint height = (uint)profileCount;

        if (width > maxWidth || height > maxHeight)
        {
            throw new ArgumentOutOfRangeException(
                nameof(profileCount),
                $"Requested container size {width}x{height} exceeds max {maxWidth}x{maxHeight}.");
        }

        ret = CLLTI.SetProfileContainerSize(device, width, height);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("SetProfileContainerSize", ret);
            throw new Exception(ErrorMessage);
        }

        // --- Configure encoder-trigger mode & exposure time ---

        _exposureTime = exposureTimeUs;
        ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_EXPOSURE_TIME, _exposureTime);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(EXPOSURE_TIME)", ret);
            throw new Exception(ErrorMessage);
        }

        // Encoder trigger on RS422, rising edge (tweak if needed)
        uint trigConfig =
            CLLTI.TRIG_MODE_ENCODER |
            CLLTI.TRIG_INPUT_RS422 |
            CLLTI.TRIG_POLARITY_HIGH |
            CLLTI.TRIG_EXT_ACTIVE;

        ret = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_TRIGGER, trigConfig);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("SetFeature(TRIGGER_ENCODER)", ret);
            throw new Exception(ErrorMessage);
        }

        // --- Prepare async state for callback ---

        _asyncProfileBuffer = new byte[totalBytes];
        _asyncProfileDataSize = (uint)singleProfileBytes; // per-profile size
        _asyncNeededProfiles = profileCount;
        _asyncReceivedProfiles = 0;
        _profileEvent.Reset();

        // Let settings settle
        await Task.Delay(120).ConfigureAwait(false);

        // --- Start transmission in NORMAL_CONTAINER_MODE ---

        ret = CLLTI.TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 1);
        if (ret < CLLTI.GENERAL_FUNCTION_OK)
        {
            SetError("TransferProfiles(start, NORMAL_CONTAINER_MODE)", ret);
            throw new Exception(ErrorMessage);
        }

        try
        {
            // Wait for a single container that holds all profiles
            bool signaled = await Task
                .Run(() => _profileEvent.WaitOne(timeoutMs))
                .ConfigureAwait(false);

            if (!signaled || _asyncReceivedProfiles < _asyncNeededProfiles)
            {
                SetError("CaptureEncoderBatchAsync timeout", CLLTI.ERROR_PROFTRANS_NO_NEW_PROFILE);
                throw new TimeoutException(
                    $"Timed out waiting for {_asyncNeededProfiles} profiles in container. Received: {_asyncReceivedProfiles}");
            }

            // Sanity check: make sure we really got N profiles worth of bytes
            int expectedBytes = singleProfileBytes * _asyncNeededProfiles;
            if (_asyncProfileBuffer == null || _asyncProfileBuffer.Length < expectedBytes)
            {
                SetError("CaptureEncoderBatchAsync buffer size mismatch", -1);
                throw new Exception("Internal async buffer size mismatch.");
            }

            // --- Convert profiles from big container buffer to List<Profile> ---

            var profiles = new List<Profile>(_asyncNeededProfiles);
            var xValues = new double[resolution];
            var zValues = new double[resolution];
            var singleBuffer = new byte[singleProfileBytes];

            for (int p = 0; p < _asyncNeededProfiles; p++)
            {
                // Take slice p from container
                Buffer.BlockCopy(
                    _asyncProfileBuffer,
                    p * singleProfileBytes,
                    singleBuffer,
                    0,
                    singleProfileBytes);

                ret = CLLTI.ConvertProfile2Values(
                    device,
                    singleBuffer,
                    resolution,
                    TProfileConfig.PROFILE,
                    _scannerType,
                    0,   // reflection 0
                    1,   // convert to mm
                    null, null, null,
                    xValues,
                    zValues,
                    null, null);

                if (((ret & CLLTI.CONVERT_X) == 0) || ((ret & CLLTI.CONVERT_Z) == 0))
                {
                    SetError("ConvertProfile2Values", ret);
                    throw new Exception(ErrorMessage);
                }

                var prof = new Profile(new List<ScanPoint>((int)resolution));
                for (int i = 0; i < resolution; i++)
                {
                    prof.Add(new ScanPoint
                    {
                        X = xValues[i],
                        Z = zValues[i]
                    });
                }

                profiles.Add(prof);
            }

            ErrorMessage = null;
            return profiles;
        }
        finally
        {
            // Stop transmission
            CLLTI.TransferProfiles(device, TTransferProfileType.NORMAL_CONTAINER_MODE, 0);

            // Optionally restore internal trigger so Poll() behaves as before
            int retRestore = CLLTI.SetFeature(device, CLLTI.FEATURE_FUNCTION_TRIGGER, CLLTI.TRIG_INTERNAL);
            if (retRestore < CLLTI.GENERAL_FUNCTION_OK)
            {
                SetError("Restore TRIG_INTERNAL", retRestore);
            }

            // Clear async state
            _asyncProfileBuffer = null;
            _asyncProfileDataSize = 0;
            _asyncNeededProfiles = 0;
            _asyncReceivedProfiles = 0;
        }
    }
    finally
    {
        Interlocked.Exchange(ref _asyncInUse, 0);
    }
}


-----

unsafe private void OnProfileCallback(byte* data, uint size)
{
    if (size == 0)
        return;

    // If we aren't currently waiting, ignore
    if (_asyncProfileBuffer == null || _asyncNeededProfiles <= 0)
        return;

    // If we've already got what we need, ignore extra callbacks
    if (_asyncReceivedProfiles >= _asyncNeededProfiles)
        return;

    int singleProfileBytes = (int)_asyncProfileDataSize;
    if (singleProfileBytes <= 0)
        return; // not configured yet

    int expectedBytes = singleProfileBytes * _asyncNeededProfiles;
    if (size != expectedBytes)
    {
        // Container size not what we expect â€“ bail out
        // (you could log this via ErrorMessage if you want)
        return;
    }

    // Copy entire container into async buffer
    IntPtr srcPtr = new IntPtr(data);
    Marshal.Copy(srcPtr, _asyncProfileBuffer, 0, (int)size);

    // Mark all profiles as received
    _asyncReceivedProfiles = _asyncNeededProfiles;

    // Signal waiting async method
    _profileEvent.Set();
}