public static PointCloud JoinCloudsSideBySideX(IReadOnlyList<PointCloud> clouds, double gap = 0)
{
    var result = new PointCloud();
    if (clouds == null || clouds.Count == 0) return result;

    double resultMaxX = double.NegativeInfinity;

    foreach (var cloud in clouds)
    {
        if (cloud?.Points == null || cloud.Points.Count == 0) continue;

        // Bounds of incoming cloud (compute once)
        double cloudMinX = cloud.Points.Min(p => p.X);
        double cloudMaxX = cloud.Points.Max(p => p.X);

        // If result already has points, shift incoming cloud so its MinX touches resultMaxX (+gap)
        if (result.Points.Count != 0)
        {
            double dx = (resultMaxX - cloudMinX) + gap;
            cloud.Offset(new(-dx, 0, 0)); // <-- if Offset takes +dx, use +dx; see note below

            // After offset, cloudMaxX shifts by same dx
            cloudMaxX += dx;
        }

        result.Join(cloud);

        // Update resultMaxX incrementally (avoid rescanning result)
        resultMaxX = double.IsNegativeInfinity(resultMaxX) ? cloudMaxX : Math.Max(resultMaxX, cloudMaxX);
    }

    return result;
}