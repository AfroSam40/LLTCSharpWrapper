using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Media.Media3D;

public static class ProjectionBackTo3D
{
    /// <summary>
    /// Maps 2D plane-coordinates (U,V) back into 3D points on the plane defined by PlaneFitResult.
    /// Assumes your 2D points are in the same plane-basis coordinates you used during projection:
    ///   U = (P - Centroid)·u,  V = (P - Centroid)·v
    /// where u,v are orthonormal axes spanning the plane.
    /// Returns 3D points: P = Centroid + U*u + V*v.
    /// </summary>
    public static Point3DCollection UVToWorld(PointCollection uvPoints, PlaneFitResult plane)
    {
        if (plane == null) throw new ArgumentNullException(nameof(plane));
        var outPts = new Point3DCollection(uvPoints?.Count ?? 0);
        if (uvPoints == null || uvPoints.Count == 0) return outPts;

        // Orthonormal basis from plane normal
        var n = plane.Normal;
        if (n.LengthSquared < 1e-18) throw new ArgumentException("Plane normal is invalid.", nameof(plane));
        n.Normalize();

        // pick a stable axis and build u,v in-plane
        var axis = Math.Abs(n.Z) < 0.9 ? new Vector3D(0, 0, 1) : new Vector3D(0, 1, 0);
        var u = Vector3D.CrossProduct(axis, n);
        if (u.LengthSquared < 1e-18) u = Vector3D.CrossProduct(new Vector3D(1, 0, 0), n);
        u.Normalize();
        var v = Vector3D.CrossProduct(n, u);
        v.Normalize();

        var c = plane.Centroid;

        for (int i = 0; i < uvPoints.Count; i++)
        {
            var uv = uvPoints[i];
            outPts.Add(c + uv.X * u + uv.Y * v);
        }
        return outPts;
    }
}