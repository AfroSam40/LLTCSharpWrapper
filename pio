using System;
using System.Collections.Generic;
using System.Numerics;
using MathNet.Numerics.LinearAlgebra;

public static class SimilarityFit3D
{
    /// <summary>
    /// Umeyama/Kabsch best-fit mapping src -> dst:
    ///   dst â‰ˆ s * R * src + t
    /// Returns a 4x4 matrix M (homogeneous) with the scale baked into the 3x3 block (s*R),
    /// plus the uniform scale s as a separate value.
    ///
    /// withScale=false => Kabsch (s=1)
    /// withScale=true  => Umeyama (uniform s)
    /// </summary>
    public static (Matrix4x4 M, double s) KabschUmeyamaMatrix(
        IReadOnlyList<Vector3> src,
        IReadOnlyList<Vector3> dst,
        bool withScale = false)
    {
        if (src is null || dst is null) throw new ArgumentNullException();
        if (src.Count != dst.Count) throw new ArgumentException("src/dst must have same length.");
        if (src.Count < 3) throw new ArgumentException("Need at least 3 point pairs.");

        int n = src.Count;

        // Centroids
        Vector3 cs = default, cd = default;
        for (int i = 0; i < n; i++) { cs += src[i]; cd += dst[i]; }
        cs /= n; cd /= n;

        // Covariance H and source variance
        var H = Matrix<double>.Build.Dense(3, 3);
        double varSrc = 0.0;

        for (int i = 0; i < n; i++)
        {
            var a = src[i] - cs;
            var b = dst[i] - cd;

            H[0, 0] += a.X * b.X; H[0, 1] += a.X * b.Y; H[0, 2] += a.X * b.Z;
            H[1, 0] += a.Y * b.X; H[1, 1] += a.Y * b.Y; H[1, 2] += a.Y * b.Z;
            H[2, 0] += a.Z * b.X; H[2, 1] += a.Z * b.Y; H[2, 2] += a.Z * b.Z;

            varSrc += a.X * a.X + a.Y * a.Y + a.Z * a.Z;
        }

        // SVD: H = U * S * V^T
        var svd = H.Svd(true);
        var U = svd.U;
        var Vt = svd.VT;
        var V = Vt.Transpose();

        // R = V * U^T
        var R = V * U.Transpose();

        // Enforce det(R)=+1 (no reflection)
        if (R.Determinant() < 0)
        {
            V[0, 2] *= -1; V[1, 2] *= -1; V[2, 2] *= -1;
            R = V * U.Transpose();
        }

        double s = 1.0;
        if (withScale)
        {
            // Umeyama uniform scale
            double traceS = svd.S.Sum();
            s = traceS / varSrc;
        }

        // t = cd - s*R*cs
        var csV = Vector<double>.Build.Dense(new[] { (double)cs.X, (double)cs.Y, (double)cs.Z });
        var cdV = Vector<double>.Build.Dense(new[] { (double)cd.X, (double)cd.Y, (double)cd.Z });
        var tV = cdV - (s * (R * csV));

        // Pack into Matrix4x4 (row-major), with scale baked into 3x3 as s*R
        float m11 = (float)(s * R[0, 0]), m12 = (float)(s * R[0, 1]), m13 = (float)(s * R[0, 2]);
        float m21 = (float)(s * R[1, 0]), m22 = (float)(s * R[1, 1]), m23 = (float)(s * R[1, 2]);
        float m31 = (float)(s * R[2, 0]), m32 = (float)(s * R[2, 1]), m33 = (float)(s * R[2, 2]);

        float tx = (float)tV[0], ty = (float)tV[1], tz = (float)tV[2];

        var M = new Matrix4x4(
            m11, m12, m13, 0f,
            m21, m22, m23, 0f,
            m31, m32, m33, 0f,
            tx,  ty,  tz,  1f
        );

        return (M, s);
    }
}